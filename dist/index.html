<!-- Test page, not relevant to the user -->

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>Test Page</title>
        <style>
            * {
                box-sizing: border-box;
            }
            html,
            body {
                width: 100%;
                height: 100%;
            }
            .err {
                color: red;
            }
            .warn {
                color: orange;
            }
        </style>
    </head>
    <body>
        <div id="log"></div>

        <script>
            const logElement = document.getElementById("log");
            const MAX_LOG_ELEMENTS = 100;
            const logMessages = [];

            function addMessage(msg, level = 0) {
                const el = document.createElement("p");
                el.textContent = msg;
                if (level === 1) {
                    el.classList.add("warn");
                }
                if (level === 2) {
                    el.classList.add("err");
                }
                const firstChild = logElement.firstChild;
                if (firstChild) {
                    logElement.insertBefore(el, firstChild);
                } else {
                    logElement.appendChild(el);
                }

                logMessages.push(el);

                while (logMessages.length > MAX_LOG_ELEMENTS) {
                    const elementToRemove = logMessages.shift();
                    logElement.removeChild(elementToRemove);
                }
            }

            const consoleLog = window.console.log;
            const consoleWarning = window.console.log;
            const consoleError = window.console.error;
            const consoleException = window.console.exception;
            const consoleDebug = window.console.debug;

            window.console.log = (...msg) =>
                addMessage(msg[0], 0) && consoleLog(...msg);
            window.console.debug = (...msg) =>
                addMessage(msg[0], 0) && consoleDebug(...msg);
            window.console.warning = (...msg) =>
                addMessage(msg[0], 1) && consoleWarning(...msg);
            window.console.error = (...msg) =>
                addMessage(msg[0], 2) && consoleError(...msg);
            window.console.exception = (msg, ex) =>
                addMessage(`${msg} Exception: ${ex}`, 2) &&
                consoleError(msg, ex);
        </script>

        <script src="main.min.js"></script>

        <script>
            let asd = null,
                asd2 = null;
            setTimeout(async () => {
                // const {
                //     accessToken
                // } = await NccIntegration.authentication.getToken(
                //     "http://auth.samuel.noccela.xyz",
                //     5662,
                //     "gZ24oMIPpD4v97N1nv9GnDLcTPpY2hV9"
                // );

                // Create NCC websocket object.
                const ncc = NccIntegration.realTime.createWSChannel(
                    "ws://partner.samuel.noccela.xyz"
                );

                // Connect to Noccela Cloud.
                try {
                    await ncc.authenticateAndConnect(
                        "http://auth.samuel.noccela.xyz",
                        5662,
                        "gZ24oMIPpD4v97N1nv9GnDLcTPpY2hV9"
                    );
                    // await ncc.connect(accessToken);
                } catch (err) {
                    alert(`Error while connecting: ${err}`);
                    return;
                }

                // Create callback that will be called with real-time location data
                // for registered devices.
                const callback = (err, payload) => {
                    for (const locationUpdate of payload) {
                        console.log(
                            `DeviceId: ${locationUpdate.deviceId}, x: ${locationUpdate.x}, y: ${locationUpdate.y}, z: ${locationUpdate.z}`
                        );
                    }
                };

                const callback2 = (err, payload) => {
                    for (const [deviceId, state] of Object.entries(payload)) {
                        console.log(
                            `Initial state for ${deviceId}: ${JSON.stringify(
                                state
                            )}`
                        );
                    }
                };

                // Register the callback and filtering information.
                // asd2 = await ncc.register(
                //     NccIntegration.EVENT_TYPES["LOCATION_UPDATE"],
                //     1, // Account
                //     1, // site
                //     { deviceIds: [1000500916] }, // Additional filters, like device ids.
                //     callback
                // );

                // Register the callback and filtering information.
                // asd2 = await ncc.register(
                //     NccIntegration.EVENT_TYPES["TAG_STATE"],
                //     1, // Account
                //     1, // site
                //     { deviceIds: [1000500916] }, // Additional filters, like device ids.
                //     callback2
                // );

                // asd2 = await ncc.register(
                //     NccIntegration.realTime.EVENT_TYPES["TAG_DIFF"],
                //     1, // Account
                //     1, // site
                //     { deviceIds: [1000500916] }, // Additional filters, like device ids.
                //     (err, asd) => console.log(`${Object.keys(asd.tags)}`)
                // );

                //const initialState = await ncc.getTagState(1, 1);
                asd = ncc;
            }, 1000);
        </script>
        <button onclick="asd.close()">close</button>
        <button onclick="asd.unregister(asd2)">unregister</button>
    </body>
</html>
